# Mysql

## 索引

MyISAM普通索引：索引顺序与数据行物理排列顺序无关

InnoDB聚集索引：聚集索引的顺序就决定了数据行的物理存储顺序,叶结点存储的是主键的值

1. **「主键索引」**(`PRIMARY KEY`)：**「唯一、非空」**
2. **「唯一索引」**(`UNIQUE`)：指定列不能出现重复数据；
3. **「前缀索引」**(`prefix INDEX`)：字符串有许多前缀重复，比如xx省xx市...；不能 order by 和 group by 
4. **「联合索引」**：一个列以上创建索引，减少开销，大量数据的表，使用联合索引会大大的减少开销。效率高。索引列越多，通过索引筛选出的数据越少。where和order by和group by**左前缀匹配原则**,遇到范围查找退化为线性查找。索引下推：命中第一个索引不回表直接筛选第二个条件的索引
5. **「覆盖索引」**：索引包含查询的所有字段的值，不用回表查询，**避免select ***出现回表查询.

**回表**：使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树叶子节点只能查到当前列值以及主键ID，所以需要根据主键ID再去查一遍数据，得到SQL 所需的列

**创建索引的策略**

- 不要在NULL值列上使用索引，尽量使用NOT NULL约束列上使用索引
- 很少查询的字段不要使用索引
- 大数据类型字段不创建索引
- 取值范围很小的列不创建索引？
- 索引对应的字段重复率太高，所以索引没用到，解决方法是建联合索引

**使用索引时的注意事项**

- 不要在条件NOT IN、<>、!= 等范围查询中使用索引
- 模糊查询时不要使用 %开头( 如 '%xxx' ,  '%xxx%')
- 查询索引的字段不要函数计算
- 联合索引查询时遵循最左原则，区分度最高的放在最左边
- 全部扫描超过30%不会走优化器；

[mysql 创建聚集索引_终于有人把MYSQL索引讲清楚了]:https://blog.csdn.net/weixin_39848007/article/details/111273706



## 优化

利用子查询优化**超多分页**场景。比如 limit offset , n 在MySQL是获取 offset + n的记录，再返回n条。而利用子查询则是查出n条，通过ID检索对应的记录出来，提高查询效率。

通过explain命令来查看SQL的执行计划，看看自己写的SQL是否走了索引，走了什么索引。通过show profile 来查看SQL对系统资源的损耗情况（不过一般还是比较少用到的）

在开启**事务**后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间（比如在事务内需要插入&&修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放

**旧数据**存到hive

有**字符串检索**场景把数据转移到Elastic Search：MySQL->Elasticsearch需要有对应的同步程序(一般就是监听MySQL的binlog，解析binlog后导入到Elasticsearch)

根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表。比如订单表按天聚合

写有性能瓶颈，升级主从架构，读写分离。还有瓶颈可以分库分表

分库分表一般可以按userid，按照用户的维度查询比较多。主键基于雪花算法或redis的较多。

**分库分表迁移过程**：双写：

1. 增量的消息各自往新表和旧表写一份 
2. 将旧表的数据迁移至新库
3. 迟早新表的数据都会追得上旧表（在某个节点上数据是同步的）
4. 校验新表和老表的数据是否正常（主要看能不能对得上）
5. 开启双读（一部分流量走新表，一部分流量走老表），相当于灰度上线的过程
6. 读流量全部切新表，停止老表的写入
7. 提前准备回滚机制，临时切换失败能恢复正常业务以及有修数据的相关程序。

**减少逻辑运算量**

- **避免使用函数**，将运算转移至易扩展的应用服务器中
   如substr等字符运算，dateadd/datesub等日期运算，abs等数学函数
- **减少排序**，利用索引取得有序数据或避免不必要排序
   如union all代替 union，order by 索引字段等
- **禁止类型转换**，使用合适类型并保证传入参数类型与数据库字段类型绝对一致
   如数字用tiny/int/bigint等，必需转换的在传入数据库之前在应用中转好
- **简单类型**，尽量避免复杂类型，降低由于复杂类型带来的附加运算。更小的数据类型占用更少的磁盘、内存、cpu缓存和cpu周期

**减少逻辑IO量**

- **index**，优化索引，减少不必要的表扫描
   如增加索引，调整组合索引字段顺序，去除选择性很差的索引字段等等
- **table**，合理拆分，适度冗余
   如将很少使用的大字段拆分到独立表，非常频繁的小字段冗余到“引用表”
- **SQL**，调整SQL写法，充分利用现有索引，避免不必要的扫描，排序及其他操作
   如减少复杂join，减少order by，尽量union all，避免子查询等
- **数据类型**，够用就好，减少不必要使用大字段
   如tinyint够用就别总是int，int够用也别老bigint，date够用也别总是timestamp



# Spring	

**IOC**容器解决对象管理和对象依赖的问题。**依赖注入**在我的理解下，是**控制反转**的实现方式为什么不New对象，好处是：将对象集中统一管理」并且「降低耦合度」类似工厂模式。方便 单元测试、对象创建复杂、对象依赖复杂、单例等。还有一整套的Bean生命周期管理，实现对象增强，AOP。

**AOP** 解决的是 非业务代码抽取的问题。监控客户端进行封装。控基本的指标有QPS、RT、ERROR等等。注解+AOP的方式封装。Spring内的事务传播行为，需要传播的方法是AOP代理对象。



# Java

## 基本

基本数据类型，`==` 比较值，引用数据类型`==` 比较内存地址(equals()默认)。

`hashCode()` 的作用是获取哈希码（`int` 整数）（本地方法c++）通常用来将对象的内存地址转换为整数之后返回。如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。重写 ``equals()`` 时必须重写 ``hashCode() ``方法。

`hashCode()`的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

基本数据类存放在栈中，对象实例存在堆。

StringBuffer线程安全，StringBuilder非线程安全。`+和+=`在String上是由StringBuilder.append()后toString()实现，但会创建多个StringBuilder对象。字符串常量池避免字符串的重复创建，在堆中。

**代理**:使用代理对象来代替对真实对象,不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能

浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。

使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。

## 集合

**判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式。**

### Map

**HashMap**

链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间

Hashtable 已经淘汰

**LinkedHashMap**:上面结构的基础上，增加了一条双向链表,保证了顺序。

**ConcurrentHashMap**保证了线程安全



### List

**ArrayList** ：出现快速失败的前提是使用了iterator进行遍历修改数据或多线程修改数据，换用`java.util.concurrent.CopyOnWriteArrayList`

**LinkedList** 双向链表

`Vector` 是 `List` 的古老实现类，底层使用`Object[ ]` 存储，线程安全的。

### Set

`HashSet` 用于不需要保证元素插入和取出顺序的场景，添加对象时先`hashcode()`若相同进一步判断`equals`()

`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet`(红黑树) 用于支持对元素自定义排序规则的场景。

## 线程

锁 

synchronized:  保证被它修饰的方法或者代码块在任意时刻只能有一个线程执

volatile 

线程池 参数是描述等待队列，成无界的有可能出现OOM

ThreadLocal:每个线程绑定自己的值

内存泄漏

## 异常

尽量缩小try...catch的范围，finally从句里放释放资源，先用IOException等专业异常处理，再用Exception兜底

## JVM虚拟机和内存调优

现系统很卡日志里频繁出现OOM异常，用dump文件看OOM时的内存镜像，看的工具可以是JMAT，通过dump文件，再结合日志上下文。原因可能：ThreadLocal里的对象用好没remove（弱引用），Redis缓存超时时间过长，创建线程池时，等待队列设置成了无界，数据库查询太多记录

[美团GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

###  Java 内存区域

**程序计数器**:线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器,是唯一一个不会出现 ``OutOfMemoryError`` 的内存区域

**Java 虚拟机栈**:线程私有的,线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出`` StackOverFlowError ``错误。栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

本地方法栈：线程私有，本地方法栈则为虚拟机使用到的 Native 方法服务。也会出现 `StackOverFlowError` 和` OutOfMemoryError `两种错误。

#### 堆

线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

**新生代**（Young Generation）

一个Eden区，两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）

Eden S0 S1



**老年代**（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，整堆包括新生代和老年代的垃圾回收称为Full GC。





Metaspace(元空间)：元空间使用的是直接内存,与垃圾回收要回收的Java对象关系不大。



### 简单调优

开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。

根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10

### GC日志

### 对象创建

1. 类加载检查
2. 分配内存
3. 初始化零值
4. 设置对象头
5. 执行init方法







# 结合

幂等=工人刷卡计件

## xxl涉及模块

大屏，看板：table滚动：Pagination直接复制current，定时器滚动进度条，满了倒着走

每天款式工序视频文件上传，ai图上传记录文件md5（客户端是wpf，web端只负责接口）

ai图转pdf并且在线显示

旧罗斯系统转移数据到新系统(或者说是只有数据库，另外做一套罗斯数据查询系统)

扫码计件api接口

出库入库,发裁片api接口

密集柜语音控制api接口

微信公众号

数据库行转列：衣服尺码size1-size20，(一个款号)行记录是尺码号，转成170，180列。

每天（月）定时任务计算漏扫码

扫码补录权限问题

总检工序疵点记录

打印二维码lodop

erp系统买的通伟服装

gitea

BigDecimal算计件工资

阿里云oss（原本放在公司公网服务器，后面转移到阿里云oss,方便设计师上传ai文件，样衣组下载）

elasticSearch用来查询员工扫码记录，数据量大。存放卡号对应款号，款式颜色等信息。（在生产的款号信息存入redis）,先日志记录计算qps

衣服的卡号二维码是aes加密的

工人刷卡(幂等)，进行查询款式信息可能涉及多个模块，使用异步来获取(feign+异步)，工人刷卡加入消息队列，保证消息可用，刷卡失败后，异常处理刷卡数据



江西厦门两地数据库同步）

厦门断电服务器关机的异地容灾（21年十月或九月，五六七三天，七厦门完全断电，江西上班）；这个需要微服务和数据库都部署多份

把兴学来的系统拆分一下数据库和模块设计。

测算每天扫码的qps，数据库和es的数据量，jmeter做压力测试，nginx动静分离，废话vue的前端

msql的逻辑删除  mybatis,一级二级缓存

# 面试

在回答好当前提问后多说一句，继续引导面试官提问。

[面试技巧](https://www.zhihu.com/question/452184164/answer/2260444337)



# 待

OOM调优

分布式日志：ELK EFK